# Juno
This repository contains my first university project, a Java development of the cards game Uno! by Mattel

The project is divided into three folders, model, view, controller, and a fourth folder contains resources. The logic of the project was structured consequently to the MVC design pattern. This file contains a detailed overview of the project, focusing on the key features.



Game management occurs almost entirely in the model, with the exception of the portions requiring mouse input and game initialization, which occur in the controller. Specifically, the GameController class, after instantiating a new Game, loads the graphics displaying the game and assigns Observers to the various Observables.

The package model.cards contains the model for all the different types of cards that can be instantiated. A superclass Card (abstract) acts as the root of all the other concrete instantiations. I have chosen to use a variation of the Singleton pattern: in the package there is the FullDeck class, which is the only one allowed to construct the various card instantiations (via a protected constructor), and its one instance is used for the construction of the Deck class, which then constitutes the actual deck used during games. I chose arbitrary card scores, and in-game score updating, for more dynamicity.

The package model.game contains the Deck, DiscardedCards and Game classes. The first, as mentioned earlier, uses a pre-built deck to be instantiated, and models all the essential behaviors of the deck: draw, rebuild, card distribution. The second class represents the discard pile, and is constructed from the Deck. Finally, the third class is Game, and is one of the main classes in the project. When constructed, it instantiates the computer-controlled Players, the Deck and DiscardedCards, and establishes the order of play. The main method, computerPlayerPlayGame, represents a computer-controlled Player's turn, and I decided to break it down into different phases, each with a function, controlled by different timers. Another method, gameHasEnded, kicks in when the game is over, and starts the closing sequence. The other methods are mainly utilities or getters.

The package model.player also consists of three classes, PlayerHand, Player and User. The first models a player's hand, with a list of cards and a number of utility methods. I chose to have this class be an Observer of the DiscardedCards class so that, the moment a card is played, all players can update the information about the cards in their hand. The second class models a generic player, and its main method is makeATurn, which performs a player turn, that is, draws a card or plays one. In addition, this method checks whether the player has won. The other methods are utility or getters. Finally, the User class, which extends the player, models a human player: it has more fields than the regular player, and more methods, almost all related to the user management section.

In the controller.game and controller.game.cards packages are the classes that interface with the human player during the game. The classes are mainly MouseListeners, and I decided to design an abstract superclass (CardHandler) so that I do not have to implement all the methods of the MouseListener interface from time to time. Finally, the ColorPicker class is the one that allows the human player to choose the color after playing a Wildcard or a +4 card.

As for the view, the game is all displayed within the GameView class, which acts as a container for the GUIs of the players, their hands, and the deck and discard pile. The graphics are updated with the Observer-Observable pattern: the GameView class is observer of the Game, the DiscardedCards class has for observer its view counterpart, and finally the playerGUIs are observer of the Players.

For graphics, I used the JavaSwing API, as recommended by the course professor. I found the implementation simple, but quite tedious for component placement.


In the course of the project, in addition to MVC, I chose to use three other design patterns.â€¨ First, a good part of the view classes make use of the singleton pattern, because there was no need for the components to be implemented in larger quantity. This pattern was also used for the creation of the FullDeck template deck, with which instances of the actual deck used during games are made. Finally, the User class makes use of a variant of this pattern: the constructor is private and a new instance is created only after login. The process is explained in detail in the Javadoc of the class.Secondly, in the controller.buttons package, I made use of the factory pattern to instantiate the different types of button behavior in the view. I chose this one in particular because it seemed the most appropriate and was the best for reducing the public interface of the package to the bare minimum. Finally, to properly implement MVC I made use of the Observer pattern, which allowed the view classes to update themselves with every change in the model. In addition, as mentioned before, I also made use of this pattern in the model, to update the players' hands after each play.



One final design note: where possible, I have always tried to minimize the public interface of any class, and, when I was sure that I had finished the project, I chose to modify a good portion of the classes with the keyword final or with package visibility, for the above reason. This particular decision was dictated by a general desire for order in the project, and a choice to eliminate as much of the superfluous as possible.
